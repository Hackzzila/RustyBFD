use std::{cmp::Ordering, time::Duration};

use num_derive::FromPrimitive;
use num_traits::FromPrimitive;

#[derive(Debug, Clone, Copy, PartialEq, Eq, FromPrimitive)]
pub enum SessionState {
  AdminDown = 0,
  Down = 1,
  Init = 2,
  Up = 3,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, FromPrimitive)]
#[repr(u8)]
pub enum Diagnostic {
  // 0 -- No Diagnostic
  NoDiagnostic = 0,
  // 1 -- Control Detection Time Expired
  TimeExpired = 1,
  // 2 -- Echo Function Failed
  EchoFailed = 2,
  // 3 -- Neighbor Signaled Session Down
  NeigborSignaledDown = 3,
  // 4 -- Forwarding Plane Reset
  ForwardingPlaneReset = 4,
  // 5 -- Path Down
  PathDown = 5,
  // 6 -- Concatenated Path Down
  ConcatPathDown = 6,
  // 7 -- Administratively Down
  AdminDown = 7,
  // 8 -- Reverse Concatenated Path Down
  ReverseConcatPathDown = 8,
}

/*
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Vers |  Diag   |Sta|P|F|C|A|D|M|  Detect Mult  |    Length     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       My Discriminator                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      Your Discriminator                       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Desired Min TX Interval                    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                   Required Min RX Interval                    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                 Required Min Echo RX Interval                 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   An optional Authentication Section MAY be present:
*/
#[derive(Debug, Clone)]
pub(crate) struct ControlPacket {
  // The version number of the protocol.  This document defines
  // protocol version 1.
  pub version: u8,

  // A diagnostic code specifying the local system's reason for the
  // last change in session state.

  // This field allows remote systems to determine the reason that the
  // previous session failed, for example.
  pub diagnostic: Diagnostic,

  // The current BFD session state as seen by the transmitting system.
  pub state: SessionState,

  // If set, the transmitting system is requesting verification of
  // connectivity, or of a parameter change, and is expecting a packet
  // with the Final (F) bit in reply.  If clear, the transmitting
  // system is not requesting verification.
  pub poll: bool,

  // If set, the transmitting system is responding to a received BFD
  // Control packet that had the Poll (P) bit set.  If clear, the
  // transmitting system is not responding to a Poll.
  pub fin: bool,

  // If set, the transmitting system's BFD implementation does not
  // share fate with its control plane (in other words, BFD is
  // implemented in the forwarding plane and can continue to function
  // through disruptions in the control plane).  If clear, the
  // transmitting system's BFD implementation shares fate with its
  // control plane.

  // The use of this bit is application dependent and is outside the
  // scope of this specification.  See specific application
  // specifications for details.
  pub control_plane_independent: bool,

  // If set, the Authentication Section is present and the session is
  // to be authenticated (see section 6.7 for details).
  pub auth_present: bool,

  // If set, Demand mode is active in the transmitting system (the
  // system wishes to operate in Demand mode, knows that the session is
  // Up in both directions, and is directing the remote system to cease
  // the periodic transmission of BFD Control packets).  If clear,
  // Demand mode is not active in the transmitting system.
  pub demand_mode: bool,

  // This bit is reserved for future point-to-multipoint extensions to
  // BFD.  It MUST be zero on both transmit and receipt.
  pub multipoint: bool,

  // Detection time multiplier.  The negotiated transmit interval,
  // multiplied by this value, provides the Detection Time for the
  // receiving system in Asynchronous mode.
  pub detect_mult: u8,

  // A unique, nonzero discriminator value generated by the
  // transmitting system, used to demultiplex multiple BFD sessions
  // between the same pair of systems.
  pub my_discriminator: u32,

  // The discriminator received from the corresponding remote system.
  // This field reflects back the received value of My Discriminator,
  // or is zero if that value is unknown.
  pub your_discriminator: u32,

  // This is the minimum interval, in microseconds, that the local
  // system would like to use when transmitting BFD Control packets,
  // less any jitter applied (see section 6.8.2).  The value zero is
  // reserved.
  pub desired_min_tx: Duration,

  // This is the minimum interval, in microseconds, between received
  // BFD Control packets that this system is capable of supporting,
  // less any jitter applied by the sender (see section 6.8.2).  If
  // this value is zero, the transmitting system does not want the
  // remote system to send any periodic BFD Control packets.
  pub required_min_rx: Duration,

  // This is the minimum interval, in microseconds, between received
  // BFD Echo packets that this system is capable of supporting, less
  // any jitter applied by the sender (see section 6.8.9).  If this
  // value is zero, the transmitting system does not support the
  // receipt of BFD Echo packets.
  pub required_min_echo_rx: Duration,
}

#[derive(Debug, Clone)]
pub(crate) enum DecodeError {
  PacketTooShort,
  PacketTooLong,
  InvalidVersion(u8),
  InvalidDiagnostic(u8),
  InvalidSessionState(u8),
  MultipointSet,
  DetectMultZero,
  MyDiscriminatorZero,
}

impl ControlPacket {
  pub(crate) fn encode(&self, out: &mut [u8]) {
    out[0] = self.version << 5;
    out[0] |= self.diagnostic as u8;

    out[1] = (self.state as u8) << 6;

    if self.poll {
      out[1] |= 0b00100000;
    }

    if self.fin {
      out[1] |= 0b00010000;
    }

    if self.control_plane_independent {
      out[1] |= 0b00001000;
    }

    if self.auth_present {
      out[1] |= 0b00000100;
    }

    if self.demand_mode {
      out[1] |= 0b00000010;
    }

    if self.multipoint {
      out[1] |= 0b00000001;
    }

    out[2] = self.detect_mult;
    out[3] = 24; // length

    out[4..8].copy_from_slice(&self.my_discriminator.to_be_bytes());
    out[8..12].copy_from_slice(&self.your_discriminator.to_be_bytes());

    let desired_min_tx = self.desired_min_tx.as_micros() as u32;
    out[12..16].copy_from_slice(&desired_min_tx.to_be_bytes());

    let required_min_rx = self.required_min_rx.as_micros() as u32;
    out[16..20].copy_from_slice(&required_min_rx.to_be_bytes());

    let required_min_echo_rx = self.required_min_echo_rx.as_micros() as u32;
    out[20..24].copy_from_slice(&required_min_echo_rx.to_be_bytes());
  }

  pub(crate) fn decode(bytes: &[u8]) -> Result<ControlPacket, DecodeError> {
    if bytes.len() < 24 {
      return Err(DecodeError::PacketTooShort);
    }

    let length = bytes[3];
    match bytes.len().cmp(&(length as usize)) {
      Ordering::Equal => {}
      Ordering::Greater => return Err(DecodeError::PacketTooLong),
      Ordering::Less => return Err(DecodeError::PacketTooShort),
    }

    let version = (bytes[0] & 0b11100000) >> 5;
    if version != 1 {
      return Err(DecodeError::InvalidVersion(version));
    }

    let diagnostic = bytes[0] & 0b00011111;
    let Some(diagnostic) = <Diagnostic as FromPrimitive>::from_u8(diagnostic) else {
      return Err(DecodeError::InvalidDiagnostic(diagnostic));
    };

    let state = (bytes[1] & 0b11000000) >> 6;
    let Some(state) = <SessionState as FromPrimitive>::from_u8(state) else {
      return Err(DecodeError::InvalidSessionState(state));
    };

    let poll = (bytes[1] & 0b00100000) == 0b00100000;
    let fin = (bytes[1] & 0b00010000) == 0b00010000;
    let control_plane_independent = (bytes[1] & 0b00001000) == 0b00001000;
    let auth_present = (bytes[1] & 0b00000100) == 0b00000100;
    let demand = (bytes[1] & 0b00000010) == 0b00000010;
    let multipoint = (bytes[1] & 0b00000001) == 0b00000001;

    if multipoint {
      return Err(DecodeError::MultipointSet);
    }

    if auth_present {
      panic!("auth not supported");
    }

    let detect_mult = bytes[2];
    if detect_mult == 0 {
      return Err(DecodeError::DetectMultZero);
    }

    let my_discriminator = u32::from_be_bytes(bytes[4..8].try_into().unwrap());
    let your_discriminator = u32::from_be_bytes(bytes[8..12].try_into().unwrap());

    if my_discriminator == 0 {
      return Err(DecodeError::MyDiscriminatorZero);
    }

    let desired_min_tx = u32::from_be_bytes(bytes[12..16].try_into().unwrap());
    let desired_min_tx = Duration::from_micros(desired_min_tx as u64);

    let required_min_rx = u32::from_be_bytes(bytes[16..20].try_into().unwrap());
    let required_min_rx = Duration::from_micros(required_min_rx as u64);

    let required_min_echo_rx = u32::from_be_bytes(bytes[20..24].try_into().unwrap());
    let required_min_echo_rx = Duration::from_micros(required_min_echo_rx as u64);

    Ok(ControlPacket {
      version,
      diagnostic,
      state,
      poll,
      fin,
      control_plane_independent,
      auth_present,
      demand_mode: demand,
      multipoint,
      detect_mult,
      my_discriminator,
      your_discriminator,
      desired_min_tx,
      required_min_rx,
      required_min_echo_rx,
    })
  }
}
